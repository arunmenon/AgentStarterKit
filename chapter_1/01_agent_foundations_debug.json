{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "course-header",
   "metadata": {},
   "source": [
    "# Module 1: Agent Foundations
    "*Building Your First Autonomous AI Agent*
    "
    "**Learning Objectives:**
    "- Understand the core components that make an AI system \"agentic\"
    "- Implement the ReAct (Reasoning + Acting) pattern
    "- Build a research assistant agent that can search and synthesize information
    "
    "**Duration:** 45 minutes
    "
    "---"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "introduction",
   "metadata": {},
   "source": [
    "## 🎯 What Makes an AI System \"Agentic\"?
    "
    "Traditional AI systems follow a simple pattern:
    "```
    "Input → Process → Output
    "```
    "
    "**Agentic AI systems** are fundamentally different. They exhibit **agency** - the ability to:
    "- **Perceive** their environment and understand context
    "- **Reason** about goals and plan actions to achieve them  
    "- **Act** autonomously in their environment
    "- **Learn** from feedback and adapt their behavior
    "
    "This creates a continuous cycle:
    "```
    "Goal → Plan → Act → Observe → Reflect → Replan → Act → ...
    "```
    "
    "### Key Characteristics of Agentic Systems:
    "1. **Autonomy:** Can operate without constant human guidance
    "2. **Goal-directed:** Work towards specific objectives
    "3. **Adaptive:** Modify behavior based on results
    "4. **Interactive:** Can use tools and interact with environments
    "5. **Persistent:** Maintain context across multiple interactions"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "setup",
   "metadata": {},
   "source": [
    "## 🛠️ Environment Setup
    "
    "Let's start by setting up our development environment with the necessary libraries and helper functions."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "imports",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Essential imports for building agents
    "import openai
    "import requests
    "import json
    "import time
    "import re
    "from typing import List, Dict, Any, Optional
    "from dataclasses import dataclass
    "from datetime import datetime
    "import os
    "from dotenv import load_dotenv
    "
    "# Load environment variables (API keys, etc.)
    "load_dotenv()
    "
    "# Helper function for pretty printing
    "def print_section(title: str, content: str):
    "    \"\"\"Helper function to format output sections clearly\"\"\"
    "    print(f\"\\n{'='*50}\")
    "    print(f\"🤖 {title}\")
    "    print(f\"{'='*50}\")
    "    print(content)
    "    print(f\"{'='*50}\\n\")
    "
    "print(\"✅ Environment setup complete!\")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "agent-anatomy",
   "metadata": {},
   "source": [
    "## 🏗️ Agent Anatomy: The Four Core Components
    "
    "Every agent consists of four essential components working together:
    "
    "### 1. **Brain (Language Model)**
    "The reasoning engine that processes information and makes decisions
    "
    "### 2. **Memory System** 
    "Stores conversation history, learned experiences, and context
    "
    "### 3. **Tool Arsenal**
    "External capabilities the agent can invoke (APIs, databases, calculators, etc.)
    "
    "### 4. **Planning System**
    "Coordinates reasoning and action selection to achieve goals
    "
    "Let's implement these components step by step:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "agent-base-class",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Base Agent class that we'll build upon
    "@dataclass
    "class AgentAction:
    "    \"\"\"Represents an action the agent wants to take\"\"\"
    "    tool_name: str
    "    tool_input: str
    "    reasoning: str
    "
    "@dataclass
    "class AgentObservation:
    "    \"\"\"Represents the result of an action\"\"\"
    "    content: str
    "    success: bool
    "    timestamp: datetime
    "
    "class BasicAgent:
    "    \"\"\"A foundational agent class implementing the core components\"\"\"
    "    
    "    def __init__(self, name: str, api_key: str):
    "        # Component 1: Brain (Language Model)
    "        self.name = name
    "        self.client = openai.OpenAI(api_key=api_key)
    "        
    "        # Component 2: Memory System
    "        self.conversation_memory = []
    "        self.experience_memory = []
    "        
    "        # Component 3: Tool Arsenal (we'll add tools here)
    "        self.tools = {}
    "        
    "        # Component 4: Planning System (tracks current goal and progress)
    "        self.current_goal = None
    "        self.plan_steps = []
    "        
    "    def add_tool(self, tool_name: str, tool_function, description: str):
    "        \"\"\"Add a new tool to the agent's arsenal\"\"\"
    "        self.tools[tool_name] = {
    "            'function': tool_function,
    "            'description': description
    "        },
    "        print(f\"✅ Added tool: {tool_name}\")
    "    
    "    def remember_experience(self, action: AgentAction, observation: AgentObservation):
    "        \"\"\"Store experience for future learning\"\"\"
    "        experience = {
    "            'action': action,
    "            'observation': observation,
    "            'timestamp': datetime.now()
    "        },
    "        self.experience_memory.append(experience)
    "
    "# Let's create our first agent instance!
    "# Note: In a real environment, you'd use your actual OpenAI API key
    "research_agent = BasicAgent(
    "    name=\"ResearchBot\", 
    "    api_key=os.getenv(\"OPENAI_API_KEY\", \"your-api-key-here\")
    ")
    "
    "print(f\"🎉 Created agent: {research_agent.name}\")
    "print(f\"📝 Memory initialized: {len(research_agent.conversation_memory)} conversations\")
    "print(f\"🛠️ Tools available: {len(research_agent.tools)} tools\")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "tools-section",
   "metadata": {},
   "source": [
    "## 🔧 Building the Tool Arsenal
    "
    "Tools are what make agents powerful! They extend the agent's capabilities beyond just text generation. Let's implement some essential tools:
    "
    "### Tool 1: Web Search
    "Allows the agent to search for current information"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "web-search-tool",
   "metadata": {},
   "outputs": [],
   "source": [
    "def web_search_tool(query: str) -> str:
    "    \"\"\"
    "    Simulates web search functionality.
    "    In production, this would integrate with real search APIs like Google, Bing, or Tavily.
    "    \"\"\"
    "    # For this educational example, we'll simulate search results
    "    # In practice, you'd integrate with actual search APIs
    "    
    "    simulated_results = {
    "        "artificial intelligence": \"AI is transforming industries through machine learning, automation, and intelligent decision-making systems.\",
    "        "climate change": \"Climate change refers to global warming and environmental shifts caused by greenhouse gas emissions.\",
    "        "quantum computing": \"Quantum computing uses quantum mechanics to process information exponentially faster than classical computers.\",
    "        "renewable energy": \"Solar, wind, and hydroelectric power are leading renewable energy sources for sustainable development.\"
    "    },
    "    
    "    # Simple keyword matching for demonstration
    "    for keyword, result in simulated_results.items():
    "        if keyword.lower() in query.lower():
    "            return f\"Search results for '{query}': {result}\"
    "    
    "    return f\"Search results for '{query}': Found general information about this topic.\"
    "
    "# Add the web search tool to our agent
    "research_agent.add_tool(
    "    tool_name=\"web_search\",
    "    tool_function=web_search_tool,
    "    description=\"Search the web for current information on any topic\"
    ")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "calculator-tool",
   "metadata": {},
   "source": [
    "### Tool 2: Calculator
    "Enables precise mathematical calculations"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "calculator-implementation",
   "metadata": {},
   "outputs": [],
   "source": [
    "def calculator_tool(expression: str) -> str:
    "    \"\"\"
    "    Safely evaluates mathematical expressions.
    "    Uses eval() with safety restrictions for educational purposes.
    "    \"\"\"
    "    try:
    "        # Basic safety: only allow mathematical operations
    "        allowed_chars = set('0123456789+-*/().^ ')
    "        if not all(c in allowed_chars for c in expression):
    "            return \"Error: Only basic mathematical operations are allowed\"
    "        
    "        # Replace ^ with ** for Python exponentiation
    "        safe_expression = expression.replace('^', '**')
    "        result = eval(safe_expression)
    "        return str(result)
    "    except Exception as e:
    "        return f\"Calculation error: {str(e)}\"
    "
    "# Add calculator tool to our agent
    "research_agent.add_tool(
    "    tool_name=\"calculator\",
    "    tool_function=calculator_tool,
    "    description=\"Perform mathematical calculations with basic operations\"
    ")
    "
    "# Test the calculator
    "test_calc = calculator_tool(\"(10 + 5) * 2\")
    "print(f\"🧮 Calculator test: (10 + 5) * 2 = {test_calc}\")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "note-tool",
   "metadata": {},
   "source": [
    "### Tool 3: Note Taking
    "Allows the agent to save important information"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "note-taking-tool",
   "metadata": {},
   "outputs": [],
   "source": [
    "def note_taking_tool(note_content: str) -> str:
    "    \"\"\"
    "    Saves important information to the agent's notes.
    "    \"\"\"
    "    # Initialize notes storage if it doesn't exist
    "    if not hasattr(research_agent, 'notes'):
    "        research_agent.notes = []
    "    
    "    # Add timestamped note
    "    note = {
    "        'content': note_content,
    "        'timestamp': datetime.now().strftime('%Y-%m-%d %H:%M:%S')
    "    },
    "    research_agent.notes.append(note)
    "    
    "    return f\"Note saved: '{note_content[:50]}{'...' if len(note_content) > 50 else ''}'\"
    "
    "# Add note-taking tool
    "research_agent.add_tool(
    "    tool_name=\"take_note\",
    "    tool_function=note_taking_tool,
    "    description=\"Save important information to notes for later reference\"
    ")
    "
    "print(f\"🛠️ Agent now has {len(research_agent.tools)} tools available!\")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "react-pattern",
   "metadata": {},
   "source": [
    "## 🧠 The ReAct Pattern: Reasoning + Acting
    "
    "The **ReAct pattern** is a fundamental approach for agentic systems. It alternates between:
    "
    "1. **Thought**: Reasoning about what to do next
    "2. **Action**: Taking a specific action (using a tool)
    "3. **Observation**: Observing the result of the action
    "4. **Reflection**: Learning from the outcome
    "
    "This cycle continues until the agent achieves its goal or determines it cannot proceed.
    "
    "### ReAct Cycle Visualization:
    "```
    "Goal: \"Research renewable energy trends\"
    "↓
    "Thought: \"I need to search for recent information\"
    "↓  
    "Action: web_search(\"renewable energy trends 2024\")
    "↓
    "Observation: \"Solar and wind energy adoption increased 25%...\"
    "↓
    "Thought: \"Let me calculate the growth rate\"
    "↓
    "Action: calculator(\"25 / 100\")
    "↓
    "Observation: \"0.25\"
    "↓
    "Thought: \"I should save this key finding\"
    "↓
    "Action: take_note(\"Renewable energy grew 25% in 2024\")
    "↓
    "Final Answer: [Comprehensive response]
    "```"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "react-implementation",
   "metadata": {},
   "outputs": [],
   "source": [
    "def execute_react_cycle(agent: BasicAgent, user_goal: str, max_iterations: int = 5) -> str:
    "    \"\"\"
    "    Implements the ReAct (Reasoning + Acting) pattern.
    "    This is the core reasoning loop that makes an agent \"agentic\".
    "    \"\"\"
    "    
    "    # Build the system prompt that teaches the agent how to use ReAct
    "    system_prompt = f\"\"\"
    "You are {agent.name}, an autonomous AI agent that can use tools to accomplish tasks.
    "
    "Available tools:
    "\"\"\"
    "    
    "    # Add tool descriptions to the prompt
    "    for tool_name, tool_info in agent.tools.items():
    "        system_prompt += f\"- {tool_name}: {tool_info['description']}\\n\"
    "    
    "    system_prompt += \"\"\"
    "Use the ReAct pattern to accomplish your goal:
    "
    "Thought: [Reason about what you need to do next]
    "Action: [tool_name]
    "Action Input: [input for the tool]
    "Observation: [You will see the tool result here]
    "
    "Continue this cycle until you can provide a Final Answer.
    "When you have enough information, respond with:
    "Final Answer: [Your complete response to the user]
    "
    "Important: Always start with a Thought about your approach.
    "\"\"\"
    "    
    "    # Initialize conversation with the user's goal
    "    messages = [
    "        {"role": \"system\", "content": system_prompt},
    "        {"role": \"user\", "content": user_goal}
    "    ]
    "    
    "    print_section(\"STARTING REACT CYCLE\", f\"Goal: {user_goal}\")
    "    
    "    for iteration in range(max_iterations):
    "        print(f\"\\n--- Iteration {iteration + 1} ---\")
    "        
    "        # Get response from the language model
    "        try:
    "            response = agent.client.chat.completions.create(
    "                model=\"gpt-4\",
    "                messages=messages,
    "                temperature=0.1,
    "                max_tokens=1000
    "            )
    "            
    "            assistant_message = response.choices[0].message.content
    "            print(f\"🤖 Agent Response:\\n{assistant_message}\")
    "            
    "            messages.append({"role": \"assistant\", "content": assistant_message})
    "            
    "        except Exception as e:
    "            print(f\"❌ Error calling language model: {e}\")
    "            return \"Error: Could not get response from language model\"
    "        
    "        # Check if we have a final answer
    "        if \"Final Answer:\" in assistant_message:
    "            final_answer = assistant_message.split(\"Final Answer:\")[-1].strip()
    "            print_section(\"TASK COMPLETED\", final_answer)
    "            return final_answer
    "        
    "        # Parse and execute action
    "        action_match = re.search(r\"Action: (\\w+)\", assistant_message)
    "        action_input_match = re.search(r\"Action Input: (.+)\", assistant_message)
    "        
    "        if action_match and action_input_match:
    "            tool_name = action_match.group(1)
    "            tool_input = action_input_match.group(1).strip()
    "            
    "            print(f\"🔧 Executing: {tool_name}({tool_input})\")
    "            
    "            # Execute the tool
    "            if tool_name in agent.tools:
    "                try:
    "                    result = agent.tools[tool_name]['function'](tool_input)
    "                    observation = f\"Observation: {result}\"
    "                    print(f\"👀 {observation}\")
    "                    
    "                    # Add observation to conversation
    "                    messages.append({"role": \"user\", "content": observation})
    "                    
    "                    # Remember this experience
    "                    action = AgentAction(
    "                        tool_name=tool_name,
    "                        tool_input=tool_input,
    "                        reasoning=assistant_message
    "                    )
    "                    obs = AgentObservation(
    "                        content=result,
    "                        success=True,
    "                        timestamp=datetime.now()
    "                    )
    "                    agent.remember_experience(action, obs)
    "                    
    "                except Exception as e:
    "                    error_msg = f\"Tool execution failed: {str(e)}\"
    "                    print(f\"❌ {error_msg}\")
    "                    messages.append({"role": \"user\", "content": f\"Observation: {error_msg}\"})
    "            else:
    "                error_msg = f\"Tool '{tool_name}' not found. Available tools: {list(agent.tools.keys())}\"
    "                print(f\"❌ {error_msg}\")
    "                messages.append({"role": \"user\", "content": f\"Observation: {error_msg}\"})
    "        else:
    "            print(\"⚠️ Could not parse action from response\")
    "            messages.append({"role": \"user\", "content": \"Observation: Could not parse action. Please use the format 'Action: tool_name' and 'Action Input: input'\"})
    "    
    "    return \"Maximum iterations reached without completing the task\"
    "
    "print(\"✅ ReAct cycle implementation ready!\")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "first-exercise",
   "metadata": {},
   "source": [
    "## 🎯 Hands-On Exercise: Your First Agentic Task
    "
    "Now it's time to see your agent in action! We'll give it a research task that requires multiple steps and tool usage.
    "
    "**Task:** \"Research the environmental impact of renewable energy and calculate the potential CO2 reduction if 50% of current fossil fuel energy was replaced by renewables.\"
    "
    "Watch how the agent:
    "1. **Reasons** about what information it needs
    "2. **Searches** for relevant data
    "3. **Calculates** specific numbers
    "4. **Synthesizes** the information into a comprehensive answer"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "exercise-execution",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Let's run our first agentic task!
    "research_task = \"\"\"
    "Research the environmental impact of renewable energy and calculate the potential CO2 reduction 
    "if 50% of current fossil fuel energy was replaced by renewables. 
    "Please provide specific numbers and save the key findings to your notes.
    "\"\"\"
    "
    "# Execute the task using our ReAct implementation
    "result = execute_react_cycle(research_agent, research_task)
    "
    "print(\"\\n\" + \"=\"*60)
    "print(\"📊 AGENT LEARNING SUMMARY\")
    "print(\"=\"*60)
    "print(f\"Experiences gained: {len(research_agent.experience_memory)}\")
    "if hasattr(research_agent, 'notes'):
    "    print(f\"Notes taken: {len(research_agent.notes)}\")
    "    for i, note in enumerate(research_agent.notes):
    "        print(f\"  {i+1}. {note['content'][:100]}...\")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "guided-exercise",
   "metadata": {},
   "source": [
    "## 💡 Guided Exercise: Build Your Own Tool
    "
    "Now it's your turn! Complete the code below to add a new tool to the agent.
    "
    "**Your Task:** Implement a \"summarizer\" tool that can create concise summaries of long text."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "guided-exercise-code",
   "metadata": {},
   "outputs": [],
   "source": [
    "def summarizer_tool(text: str) -> str:
    "    \"\"\"
    "    Create a concise summary of the input text.
    "    
    "    YOUR TASK: Complete this function implementation.
    "    
    "    Hints:
    "    - For this exercise, create a simple rule-based summarizer
    "    - Extract the first and last sentences
    "    - Or find sentences containing key words like \"important\", \"key\", \"significant\"
    "    - Return a summary that's roughly 1/3 the length of the original
    "    \"\"\"
    "    
    "    ### START CODE HERE ###
    "    
    "    # Split text into sentences
    "    sentences = # YOUR CODE: Split the text into sentences
    "    
    "    if len(sentences) <= 2:
    "        return text  # Return original if already short
    "    
    "    # Simple summarization strategy: first sentence + key sentences + last sentence
    "    summary_sentences = []
    "    
    "    # Always include first sentence
    "    summary_sentences.append(# YOUR CODE: Add first sentence)
    "    
    "    # Find sentences with key words
    "    key_words = ['important', 'significant', 'key', 'crucial', 'main', 'primary']
    "    for sentence in sentences[1:-1]:  # Skip first and last
    "        # YOUR CODE: Check if sentence contains any key words
    "        if # YOUR CONDITION:
    "            summary_sentences.append(sentence)
    "    
    "    # Always include last sentence if we have room
    "    if len(summary_sentences) < len(sentences) // 2:
    "        summary_sentences.append(# YOUR CODE: Add last sentence)
    "    
    "    # Join and return
    "    return # YOUR CODE: Join summary sentences
    "    
    "    ### END CODE HERE ###
    "
    "# Test your implementation
    "test_text = \"\"\"
    "Artificial intelligence is transforming many industries today. 
    "Machine learning algorithms can process vast amounts of data quickly. 
    "The key benefit is improved decision-making capabilities. 
    "Companies are investing heavily in AI research and development. 
    "However, important ethical considerations must be addressed. 
    "The future of AI looks very promising for solving complex problems.
    "\"\"\"
    "
    "test_summary = summarizer_tool(test_text.strip())
    "print(\"📄 Original text:\")
    "print(test_text)
    "print(\"\\n📝 Your summary:\")
    "print(test_summary)
    "
    "# Add your tool to the agent
    "research_agent.add_tool(
    "    tool_name=\"summarize\",
    "    tool_function=summarizer_tool,
    "    description=\"Create a concise summary of long text content\"
    ")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "solution-reveal",
   "metadata": {},
   "source": [
    "### 🔍 Solution Reveal
    "
    "Click below to see the solution if you need help:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "solution-code",
   "metadata": {},
   "outputs": [],
   "source": [
    "# SOLUTION - Don't peek until you've tried!
    "\"\"\"
    "def summarizer_tool(text: str) -> str:
    "    # Split text into sentences
    "    sentences = [s.strip() for s in text.split('.') if s.strip()]
    "    
    "    if len(sentences) <= 2:
    "        return text
    "    
    "    summary_sentences = []
    "    
    "    # Always include first sentence
    "    summary_sentences.append(sentences[0])
    "    
    "    # Find sentences with key words
    "    key_words = ['important', 'significant', 'key', 'crucial', 'main', 'primary']
    "    for sentence in sentences[1:-1]:
    "        if any(word in sentence.lower() for word in key_words):
    "            summary_sentences.append(sentence)
    "    
    "    # Always include last sentence if we have room
    "    if len(summary_sentences) < len(sentences) // 2:
    "        summary_sentences.append(sentences[-1])
    "    
    "    return '. '.join(summary_sentences) + '.'
    "\"\"\"
    "
    "print(\"💡 Solution revealed above! Compare with your implementation.\")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "test-new-tool",
   "metadata": {},
   "source": [
    "## 🧪 Test Your Enhanced Agent
    "
    "Now let's test your agent with its new summarization capability!"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "test-enhanced-agent",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Test the enhanced agent with a task that uses the new tool
    "enhanced_task = \"\"\"
    "Research information about quantum computing, then summarize the key points, 
    "and save a note about the most important finding.
    "\"\"\"
    "
    "enhanced_result = execute_react_cycle(research_agent, enhanced_task)
    "
    "print(f\"\\n🎯 Agent now has {len(research_agent.tools)} tools:\")
    "for tool_name in research_agent.tools.keys():
    "    print(f\"  ✅ {tool_name}\")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "knowledge-check",
   "metadata": {},
   "source": [
    "## 📝 Knowledge Check
    "
    "Test your understanding with these questions:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "knowledge-check-code",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Interactive Knowledge Check
    "def knowledge_check():
    "    questions = [
    "        {
    "            "question": \"What are the four core components of an agentic system?\",
    "            "options": [
    "                \"A) Input, Process, Output, Memory\",
    "                \"B) Brain, Memory, Tools, Planning\", 
    "                \"C) Data, Model, API, Interface\",
    "                \"D) Search, Calculate, Summarize, Store\"
    "            ],
    "            "correct": \"B\"
    "        },
    "        {
    "            "question": \"What does ReAct stand for?\",
    "            "options": [
    "                \"A) Retrieve and Act\",
    "                \"B) Reason and Activate\",
    "                \"C) Reasoning and Acting\",
    "                \"D) Research and Action\"
    "            ],
    "            "correct": \"C\"
    "        },
    "        {
    "            "question": \"What makes an AI system 'agentic'?\",
    "            "options": [
    "                \"A) Using large language models\",
    "                \"B) Having a nice user interface\", 
    "                \"C) Autonomy, goal-direction, and environmental interaction\",
    "                \"D) Being very fast and accurate\"
    "            ],
    "            "correct": \"C\"
    "        },
    "    ]
    "    
    "    score = 0
    "    for i, q in enumerate(questions, 1):
    "        print(f\"\\nQuestion {i}: {q['question']}\")
    "        for option in q['options']:
    "            print(f\"  {option}\")
    "        
    "        # In a real notebook, you'd use input() here
    "        # For this example, we'll show the correct answer
    "        print(f\"\\n✅ Correct Answer: {q['correct']}\")
    "        
    "        # Explanation
    "        if q['correct'] == 'B' and i == 1:
    "            print(\"💡 The four components work together: Brain (LLM) for reasoning, Memory for context, Tools for capabilities, Planning for coordination.\")
    "        elif q['correct'] == 'C' and i == 2:
    "            print(\"💡 ReAct alternates between reasoning about what to do and taking actions to achieve goals.\")
    "        elif q['correct'] == 'C' and i == 3:
    "            print(\"💡 Agentic systems can operate autonomously, work toward goals, and interact with their environment.\")
    "    
    "    print(\"\\n🎯 Knowledge check complete! Review any concepts you'd like to understand better.\")
    "
    "knowledge_check()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "reflection",
   "metadata": {},
   "source": [
    "## 🎯 Module 1 Summary
    "
    "Congratulations! You've successfully built your first agentic AI system. Let's reflect on what you've accomplished:
    "
    "### ✅ What You Built:
    "- **Complete Agent Architecture** with all four core components
    "- **ReAct Implementation** that can reason and act autonomously
    "- **Tool Integration System** with web search, calculator, and note-taking
    "- **Memory System** that learns from experience
    "- **Custom Tool Development** (your summarizer)
    "
    "### 🧠 Key Concepts Mastered:
    "- **Agency** vs. traditional AI systems
    "- **ReAct Pattern** for autonomous reasoning
    "- **Tool Integration** for extending capabilities
    "- **Memory and Learning** for continuous improvement
    "
    "### 🚀 Next Steps:
    "In Module 2, you'll learn to:
    "- Implement advanced memory systems
    "- Create agents that learn from conversation history
    "- Build context-aware conversational agents
    "- Handle long-term memory and knowledge retention
    "
    "### 💪 Challenge Exercise (Optional):
    "Before moving to Module 2, try enhancing your agent with:
    "1. A \"weather\" tool that provides current weather information
    "2. A \"translator\" tool for basic language translation
    "3. A task that requires using all tools in sequence
    "
    "### 📊 Progress Tracker:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "progress-tracker",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Progress Summary
    "def module_progress_summary():
    "    print(\"📈 MODULE 1 PROGRESS SUMMARY\")
    "    print(\"=\" * 40)
    "    
    "    # Agent capabilities
    "    capabilities = [
    "        \"✅ Basic agent architecture\",
    "        \"✅ ReAct reasoning pattern\", 
    "        \"✅ Tool integration system\",
    "        \"✅ Memory and experience tracking\",
    "        \"✅ Custom tool development\"
    "    ]
    "    
    "    print(\"\\n🛠️ Agent Capabilities Built:\")
    "    for cap in capabilities:
    "        print(f\"  {cap}\")
    "    
    "    print(f\"\\n📊 Agent Statistics:\")
    "    print(f\"  • Tools available: {len(research_agent.tools)}\")
    "    print(f\"  • Experiences gained: {len(research_agent.experience_memory)}\")
    "    if hasattr(research_agent, 'notes'):
    "        print(f\"  • Notes taken: {len(research_agent.notes)}\")
    "    
    "    print(f\"\\n🎯 Ready for Module 2: Advanced Memory and Learning!\")
    "    print(f\"\\n💡 Pro Tip: The agent you built here is the foundation for all advanced patterns we'll explore!\")
    "
    "module_progress_summary()"
   ]
  },
 ],
 "metadata": {
  "kernelspec": {
   "display_name": \"Python 3\",
   "language": \"python\",
   "name": \"python3\"
  },
  "language_info": {
   "codemirror_mode": {
    "name": \"ipython\",
    "version": 3
   },
   "file_extension": \".py\",
   "mimetype": \"text/x-python\",
   "name": \"python\",
   "nbconvert_exporter": \"python\",
   "pygments_lexer": \"ipython3\",
   "version": \"3.8.0\"
  }\n }\n}